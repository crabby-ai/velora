//! Core types for the strategy framework.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Trading signal generated by a strategy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Signal {
    /// No action - hold current position
    Hold,

    /// Open a long position
    Buy {
        /// Symbol to trade
        symbol: String,
        /// Quantity to buy (units or contracts)
        quantity: f64,
        /// Optional limit price
        limit_price: Option<f64>,
        /// Optional stop price
        stop_price: Option<f64>,
        /// Strategy-specific metadata
        metadata: HashMap<String, String>,
    },

    /// Open a short position
    Sell {
        /// Symbol to trade
        symbol: String,
        /// Quantity to sell (units or contracts)
        quantity: f64,
        /// Optional limit price
        limit_price: Option<f64>,
        /// Optional stop price
        stop_price: Option<f64>,
        /// Strategy-specific metadata
        metadata: HashMap<String, String>,
    },

    /// Close an existing position
    Close {
        /// Symbol to close
        symbol: String,
        /// Optional quantity (None = close entire position)
        quantity: Option<f64>,
        /// Strategy-specific metadata
        metadata: HashMap<String, String>,
    },

    /// Modify an existing position
    Modify {
        /// Symbol to modify
        symbol: String,
        /// New stop loss price
        stop_loss: Option<f64>,
        /// New take profit price
        take_profit: Option<f64>,
        /// Strategy-specific metadata
        metadata: HashMap<String, String>,
    },
}

impl Signal {
    /// Create a simple buy signal
    pub fn buy(symbol: impl Into<String>, quantity: f64) -> Self {
        Self::Buy {
            symbol: symbol.into(),
            quantity,
            limit_price: None,
            stop_price: None,
            metadata: HashMap::new(),
        }
    }

    /// Create a simple sell signal
    pub fn sell(symbol: impl Into<String>, quantity: f64) -> Self {
        Self::Sell {
            symbol: symbol.into(),
            quantity,
            limit_price: None,
            stop_price: None,
            metadata: HashMap::new(),
        }
    }

    /// Create a simple close signal
    pub fn close(symbol: impl Into<String>) -> Self {
        Self::Close {
            symbol: symbol.into(),
            quantity: None,
            metadata: HashMap::new(),
        }
    }

    /// Check if signal is actionable (not Hold)
    pub fn is_actionable(&self) -> bool {
        !matches!(self, Signal::Hold)
    }

    /// Get the symbol for this signal
    pub fn symbol(&self) -> Option<&str> {
        match self {
            Signal::Hold => None,
            Signal::Buy { symbol, .. } => Some(symbol),
            Signal::Sell { symbol, .. } => Some(symbol),
            Signal::Close { symbol, .. } => Some(symbol),
            Signal::Modify { symbol, .. } => Some(symbol),
        }
    }
}

/// Position side
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum PositionSide {
    /// Long position
    Long,
    /// Short position
    Short,
}

/// Current position held by the strategy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Position {
    /// Trading symbol
    pub symbol: String,
    /// Position side
    pub side: PositionSide,
    /// Quantity held
    pub quantity: f64,
    /// Average entry price
    pub entry_price: f64,
    /// Current market price
    pub current_price: f64,
    /// When position was opened
    pub opened_at: DateTime<Utc>,
    /// When position was last updated
    pub updated_at: DateTime<Utc>,
    /// Stop loss price (if set)
    pub stop_loss: Option<f64>,
    /// Take profit price (if set)
    pub take_profit: Option<f64>,
    /// Unrealized P&L
    pub unrealized_pnl: f64,
    /// Position metadata
    pub metadata: HashMap<String, String>,
}

impl Position {
    /// Create a new position
    pub fn new(
        symbol: impl Into<String>,
        side: PositionSide,
        quantity: f64,
        entry_price: f64,
    ) -> Self {
        let now = Utc::now();
        Self {
            symbol: symbol.into(),
            side,
            quantity,
            entry_price,
            current_price: entry_price,
            opened_at: now,
            updated_at: now,
            stop_loss: None,
            take_profit: None,
            unrealized_pnl: 0.0,
            metadata: HashMap::new(),
        }
    }

    /// Update current price and recalculate P&L
    pub fn update_price(&mut self, price: f64) {
        self.current_price = price;
        self.updated_at = Utc::now();

        // Calculate unrealized P&L
        match self.side {
            PositionSide::Long => {
                self.unrealized_pnl = (price - self.entry_price) * self.quantity;
            }
            PositionSide::Short => {
                self.unrealized_pnl = (self.entry_price - price) * self.quantity;
            }
        }
    }

    /// Check if stop loss is hit
    pub fn is_stop_loss_hit(&self) -> bool {
        if let Some(stop_loss) = self.stop_loss {
            match self.side {
                PositionSide::Long => self.current_price <= stop_loss,
                PositionSide::Short => self.current_price >= stop_loss,
            }
        } else {
            false
        }
    }

    /// Check if take profit is hit
    pub fn is_take_profit_hit(&self) -> bool {
        if let Some(take_profit) = self.take_profit {
            match self.side {
                PositionSide::Long => self.current_price >= take_profit,
                PositionSide::Short => self.current_price <= take_profit,
            }
        } else {
            false
        }
    }

    /// Get current position value
    pub fn value(&self) -> f64 {
        self.quantity * self.current_price
    }

    /// Get return percentage
    pub fn return_pct(&self) -> f64 {
        match self.side {
            PositionSide::Long => {
                ((self.current_price - self.entry_price) / self.entry_price) * 100.0
            }
            PositionSide::Short => {
                ((self.entry_price - self.current_price) / self.entry_price) * 100.0
            }
        }
    }
}

/// Strategy state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum StrategyState {
    /// Strategy is initializing
    Initializing,
    /// Strategy is running
    Running,
    /// Strategy is paused
    Paused,
    /// Strategy has stopped
    Stopped,
    /// Strategy encountered an error
    Error,
}

/// Strategy configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyConfig {
    /// Strategy name
    pub name: String,
    /// Strategy version
    pub version: String,
    /// Symbols to trade
    pub symbols: Vec<String>,
    /// Initial capital
    pub initial_capital: f64,
    /// Maximum position size as percentage of capital (0-100)
    pub max_position_size_pct: f64,
    /// Maximum number of concurrent positions
    pub max_positions: usize,
    /// Enable position sizing based on volatility
    pub use_volatility_sizing: bool,
    /// Custom configuration parameters
    pub parameters: HashMap<String, serde_json::Value>,
}

impl Default for StrategyConfig {
    fn default() -> Self {
        Self {
            name: "Unnamed Strategy".to_string(),
            version: "0.1.0".to_string(),
            symbols: vec![],
            initial_capital: 10_000.0,
            max_position_size_pct: 10.0,
            max_positions: 5,
            use_volatility_sizing: false,
            parameters: HashMap::new(),
        }
    }
}

impl StrategyConfig {
    /// Create a new strategy configuration
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            ..Default::default()
        }
    }

    /// Set symbols to trade
    pub fn with_symbols(mut self, symbols: Vec<String>) -> Self {
        self.symbols = symbols;
        self
    }

    /// Set initial capital
    pub fn with_capital(mut self, capital: f64) -> Self {
        self.initial_capital = capital;
        self
    }

    /// Set maximum position size percentage
    pub fn with_max_position_size(mut self, pct: f64) -> Self {
        self.max_position_size_pct = pct;
        self
    }

    /// Add a custom parameter
    pub fn with_parameter(mut self, key: impl Into<String>, value: serde_json::Value) -> Self {
        self.parameters.insert(key.into(), value);
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_creation() {
        let signal = Signal::buy("BTC-USD-PERP", 0.5);
        assert!(signal.is_actionable());
        assert_eq!(signal.symbol(), Some("BTC-USD-PERP"));

        let hold = Signal::Hold;
        assert!(!hold.is_actionable());
        assert_eq!(hold.symbol(), None);
    }

    #[test]
    fn test_position_pnl() {
        let mut pos = Position::new("BTC-USD-PERP", PositionSide::Long, 1.0, 50000.0);

        // Price goes up
        pos.update_price(51000.0);
        assert_eq!(pos.unrealized_pnl, 1000.0);
        assert_eq!(pos.return_pct(), 2.0);

        // Price goes down
        pos.update_price(49000.0);
        assert_eq!(pos.unrealized_pnl, -1000.0);
        assert_eq!(pos.return_pct(), -2.0);
    }

    #[test]
    fn test_position_short_pnl() {
        let mut pos = Position::new("BTC-USD-PERP", PositionSide::Short, 1.0, 50000.0);

        // Price goes down (profit for short)
        pos.update_price(49000.0);
        assert_eq!(pos.unrealized_pnl, 1000.0);
        assert_eq!(pos.return_pct(), 2.0);

        // Price goes up (loss for short)
        pos.update_price(51000.0);
        assert_eq!(pos.unrealized_pnl, -1000.0);
        assert_eq!(pos.return_pct(), -2.0);
    }

    #[test]
    fn test_stop_loss() {
        let mut pos = Position::new("BTC-USD-PERP", PositionSide::Long, 1.0, 50000.0);
        pos.stop_loss = Some(49000.0);

        pos.update_price(49500.0);
        assert!(!pos.is_stop_loss_hit());

        pos.update_price(48500.0);
        assert!(pos.is_stop_loss_hit());
    }

    #[test]
    fn test_take_profit() {
        let mut pos = Position::new("BTC-USD-PERP", PositionSide::Long, 1.0, 50000.0);
        pos.take_profit = Some(52000.0);

        pos.update_price(51000.0);
        assert!(!pos.is_take_profit_hit());

        pos.update_price(52500.0);
        assert!(pos.is_take_profit_hit());
    }

    #[test]
    fn test_config_builder() {
        let config = StrategyConfig::new("Test Strategy")
            .with_symbols(vec!["BTC-USD-PERP".to_string()])
            .with_capital(100_000.0)
            .with_max_position_size(15.0);

        assert_eq!(config.name, "Test Strategy");
        assert_eq!(config.initial_capital, 100_000.0);
        assert_eq!(config.max_position_size_pct, 15.0);
    }
}
